# Other

### This file contains writeups for the easier binary exploitation challenges that have fairly short solutions.

## **Contents**

- [basic-file-exploit](#basic-file-exploit---100-pts)
- [CVE-XXXX-XXXXX](#cve-xxxx-xxxxx---100-pts)
- [Buffer Overflow](#buffer-overflow-0-3)
  - [Buffer Overflow 0](#buffer-overflow-0)
  - [Buffer Overflow 1](#buffer-overflow-1)
  - [Buffer Overflow 2](#buffer-overflow-2)
  - [Buffer Overflow 3](#buffer-overflow-3)

# basic-file-exploit - 100 pts

> The program provided allows you to write to a file and read what you wrote from it. Try playing around with it and see if you can break it!
> Connect to the program with netcat:
> `$ nc saturn.picoctf.net 53641`
> The program's source code with the flag redacted can be downloaded here.

## Solution

Open the source code.

The flag is printed here:

```
if ((entry_number = strtol(entry, NULL, 10)) == 0) {
    puts(flag);
    fseek(stdin, 0, SEEK_END);
    exit(0);
}
```

`strtol` converts the first long in the string to a long type. It returns 0 if a long is not found. So, we just have to enter a string that does not contain a number.

Before we do that, we have to write some data first, otherwise we cannot enter that function as the program says that there is no data to read yet.

```
$ nc saturn.picoctf.net 53641
Hi, welcome to my echo chamber!
Type '1' to enter a phrase into our database
Type '2' to echo a phrase in our database
Type '3' to exit the program
2
2
No data yet
1
1
Please enter your data:
test
test
Please enter the length of your data:
4
4
Your entry number is: 1
Write successful, would you like to do anything else?
2
2
Please enter the entry number of your data:
givemetheflag
givemetheflag
picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_C5BC1889}
```

## Flag

> `picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_C5BC1889}`

---

# CVE-XXXX-XXXXX - 100 pts

> Enter the CVE of the vulnerability as the flag with the correct flag format: `picoCTF{CVE-XXXX-XXXXX}` replacing XXXX-XXXXX with the numbers for the matching vulnerability. The CVE we're looking for is the first recorded remote code execution (RCE) vulnerability in 2021 in the Windows Print Spooler Service, which is available across desktop and server versions of Windows operating systems. The service is used to manage printers and print servers.

## Solution

Some Google searching will bring up the correct number. Here is a [resource](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527) on the vulnerability.

## Flag

> `picoCTF{CVE-2021-34527}`

---

# Buffer Overflow 0-3

This series of challenges involves various levels of buffer overflow.

This series is practically a clone of the 2018 buffer overflow questions, with more or less the same solutions for each challenge. There are many writeups for these challenges already, so I will just provide very brief solutions here.

The general solution is to find the vulnerability in the source code, find the offset in a debugger such as GDB, find the addresses you need using a decompiler/dissassembler such as objdump or Ghidra, then craft your payload.

## Buffer Overflow 0

Basic buffer overflow. The buffer size is 16 bytes. Entering 20+ bytes will trigger the segmentation fault handler function, which prints the flag.

### Flag

> `picoCTF{ov3rfl0ws_ar3nt_that_bad_8ba275ff}`

## Buffer Overflow 1

Find the offset of the return address, then overwrite it to the address of `win()`.

### Flag

> `picoCTF{addr3ss3s_ar3_3asy_c76b273b}`

## Buffer Overflow 2

Find the offset of the return address, then overwrite it to the address of `win()`, followed by the arguments `0xCAFEF00D` and `0xF00DF00D`.

### Flag

> `picoCTF{argum3nt5_4_d4yZ_31432deb}`

## Buffer Overflow 3

When the stack is overflowed and the canary is overwritten, the program will exit. Overflow the stack so that the canary value is overwritten with its original value.

Brute force the canary byte-by-byte. You will know if a byte is correct because the program will not complain about the canary. Then, move on to the next byte. The canary turns out to be `BiRd`. Find the offsets and include the canary and the address of `win()` correctly.

### Flag

> `picoCTF{Stat1C_c4n4r13s_4R3_b4D_9602b3a1}`
